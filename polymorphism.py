# POLYMORPHISM  (Operator Overloading)

# Same Operator has different function depending on the condition  

print(1+2) #3
print("Hi "+"Jonathan") # Hi Jonathan (Concatenate)
print([1,2,3]+[4,5,6]) # Merge


print("\n")
# All the above cases are the implicit Operator Overloading, predefined in Python

#### Explicit Operator Overloading ####

# Example of Imaginary Numbers

class Complex:
    def __init__(self,real,img):
        self.real=real
        self.img=img
        
    def show(self):
        print(self.real,"i +",self.img,"j")
        
    def add(self,num2):     # This function is defined without using dunder function
        newReal=self.real+num2.real
        newImg=self.img+num2.img
        return Complex(newReal,newImg)

print("Imaginary Number")
n1=Complex(23,21)
n1.show()
n2=Complex(2,6)
n2.show()

print("\n")
print("The Sum below is wihtout the dunder function, so it is generated by n3=n1.add(n2)")


n3=n1.add(n2)       # Instead of this if we wanted num3 = num1 + num2, it would give error, that is where we use
n3.show()           # Dunder functions


# Here comes the use of Dunder functions (Functions which have 2 underscores before and after)


class Complex:
    def __init__(self,real,img):
        self.real=real
        self.img=img
        
    def show(self):
        print(self.real,"i +",self.img,"j")
        
    def __add__(self,num2):     # This function is defined using dunder function
        newReal=self.real+num2.real
        newImg=self.img+num2.img
        return Complex(newReal,newImg)
    
    def __sub__(self,num2):    
        newReal=self.real-num2.real
        newImg=self.img-num2.img
        return Complex(newReal,newImg)

print("\n")


print("Imaginary Number")
n1=Complex(23,21)
n1.show()
n2=Complex(2,6)
n2.show()

print("\n")


print("The Sum below is wihtout the dunder function, so it is generated by n3=n1+n2")


n3=n1+n2
print("Addition")
n3.show()
n4=n1-n2
print("Subtraction")
n4.show()
